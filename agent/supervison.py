""" <WIP>
AI Strategy Supervising Analyst Agent
Analyzes historical strategy backtests to identify optimal trade entries based on previously generated code.
This Python script implements an AI agent that analyzes historical trading strategy performance from an Excel report and provides actionable suggestions for future trades. The agent processes backtest results generated by the strategy-generating AI to identify optimal entry points and improve trading performance.

Input: Excel report from reports/reports containing:
    - Strategy prompts
    - Generated code
    - Backtest results
    
Output: Actionable trading suggestions based on best-performing historical patterns.

# Features:

1) Excel Report Analysis (Reads and parses Excel reports containing):
- Historical trading prompts (strategy descriptions)
- Generated strategy code
- Backtest performance metrics
- Entry/exit points and their results

2) Performance Evaluation(Identifies the most successful historical strategies based on):
- Profitability metrics (ROI, Sharpe ratio, win rate)
- Risk-adjusted returns
- Consistency across market conditions

3) Suggestion Generation(Recommends optimal trade entries by):
- Finding patterns in successful historical trades
- Analyzing market conditions that led to best performance
- Identifying undervalued opportunities based on past successes
- Calculating risk/reward ratios for potential entries

Continuous Learning:
- Maintains and updates knowledge base from new backtest results
- Adapts suggestions based on evolving market conditions
- Tracks suggestion performance to improve future recommendations

Output the agent should provide:
- Ranked list of best historical strategies
- Actionable suggestions for future trades
- Suggested entries with:
    - Expected performance
    - Confidence scores
    - Similar historical patterns
- Updated Insights report with new suggestions
"""
"""
AI Strategy Supervising Analyst Agent
Ranks every historical strategy run and (optionally) feeds the best
performer back to other modules.

✓  reads   ./reports/strategy_results.xlsx
✓  scores  ROI • Sharpe • Drawdown • Trade‑count
✓  analyse(top_n=3)   → JSON suggestions from LLM
✓  best_historical()  → dict with description, code & metrics of the champion
"""

from __future__ import annotations

import json, os
from datetime import datetime
from pathlib import Path

import pandas as pd
from dotenv import load_dotenv
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI

# ─── config ────────────────────────────────────────────────────────────
load_dotenv()

REPORT_FILE = "strategy_results.xlsx"
TOP_N       = 3

WEIGHTS = {"return": 0.35, "sharpe": 0.35, "drawdown": 0.15, "trades": 0.15}

LLM = ChatOpenAI(
    model       = "nvidia/llama-3.3-nemotron-super-49b-v1",
    api_key     = os.getenv("OPENAI_API_KEY"),
    base_url    = "https://integrate.api.nvidia.com/v1",
    temperature = 0.4,
)

PROMPT = PromptTemplate.from_template("""
You are a senior quantitative strategist.

For each of the {top_n} strategy records below (JSON list), return:
  • `strategy_id`          – use its timestamp
  • `summary`              – ≤30 words on why it outperformed
  • `tweak`                – one concrete improvement
  • `sl_pct`, `tp_pct`     – stop‑loss / take‑profit in %
  • `exp_return_3mo`       – expected 3‑month return in %
  • `confidence`           – 0–1

DATA:
{data}
""")

# ─── internal helpers ──────────────────────────────────────────────────
def _report_path() -> Path:
    """Absolute path to the Excel log."""
    return (Path(__file__).parent / ".." / "reports" / REPORT_FILE).resolve()

def _compute_score(df: pd.DataFrame) -> pd.Series:
    pct = lambda s: s.rank(pct=True)
    return (
          WEIGHTS["return"]   * pct(df["improved_return_pct"])
        + WEIGHTS["sharpe"]   * pct(df["improved_sharpe"])
        + WEIGHTS["drawdown"] * (1 - pct(df["improved_max_drawdown_pct"]))
        + WEIGHTS["trades"]   * pct(df["improved_n_trades"])
    )

# ─── public API ────────────────────────────────────────────────────────
def analyse(top_n: int = TOP_N) -> str:
    """Ask the LLM for improvement ideas on the current Top‑N strategies."""
    df = pd.read_excel(_report_path())
    df["score"] = _compute_score(df)
    df_top      = df.nlargest(top_n, "score")

    prompt = PROMPT.format(
        top_n = top_n,
        data  = json.dumps(df_top.to_dict("records"), indent=2)
    )
    resp   = LLM.invoke(prompt)
    text   = resp.get("text", resp) if isinstance(resp, dict) else str(resp)

    # save for history
    out_dir = _report_path().parent / "insights"
    out_dir.mkdir(exist_ok=True)
    stamp   = datetime.now().strftime("%Y%m%d_%H%M%S")
    (out_dir / f"insights_{stamp}.json").write_text(text)

    return text


def best_historical(keep_cols: list[str] | None = None) -> dict[str, str]:
    """
    Return a dict describing the single best strategy ever logged.
    Default columns: description • code • metrics.
    """
    df = pd.read_excel(_report_path())
    df["score"] = _compute_score(df)
    row = df.loc[df["score"].idxmax()]

    cols = keep_cols or [
        "strategy_description",
        "strategy_code",
        "improved_backtest_results",
    ]
    return {c: str(row[c]) for c in cols if c in row}


# ─── CLI helper ────────────────────────────────────────────────────────
if __name__ == "__main__":
    print(analyse())
