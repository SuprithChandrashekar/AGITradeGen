""" <WIP>
AI Strategy Supervising Analyst Agent
Analyzes historical strategy backtests to identify optimal trade entries based on previously generated code.
This Python script implements an AI agent that analyzes historical trading strategy performance from an Excel report and provides actionable suggestions for future trades. The agent processes backtest results generated by the strategy-generating AI to identify optimal entry points and improve trading performance.

Input: Excel report from reports/reports containing:
    - Strategy prompts
    - Generated code
    - Backtest results
    
Output: Actionable trading suggestions based on best-performing historical patterns.

# Features:

1) Excel Report Analysis (Reads and parses Excel reports containing):
- Historical trading prompts (strategy descriptions)
- Generated strategy code
- Backtest performance metrics
- Entry/exit points and their results

2) Performance Evaluation(Identifies the most successful historical strategies based on):
- Profitability metrics (ROI, Sharpe ratio, win rate)
- Risk-adjusted returns
- Consistency across market conditions

3) Suggestion Generation(Recommends optimal trade entries by):
- Finding patterns in successful historical trades
- Analyzing market conditions that led to best performance
- Identifying undervalued opportunities based on past successes
- Calculating risk/reward ratios for potential entries

Continuous Learning:
- Maintains and updates knowledge base from new backtest results
- Adapts suggestions based on evolving market conditions
- Tracks suggestion performance to improve future recommendations

Output the agent should provide:
- Ranked list of best historical strategies
- Actionable suggestions for future trades
- Suggested entries with:
    - Expected performance
    - Confidence scores
    - Similar historical patterns
- Updated Insights report with new suggestions
"""
from __future__ import annotations
import os
import json
from datetime import datetime
from pathlib import Path

import pandas as pd
from dotenv import load_dotenv
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI

# ──────────────────────────────────────────────
# Configuration
# ──────────────────────────────────────────────
load_dotenv()

REPORT_FILE      = "strategy_results.xlsx"   # Excel file inside ../reports/
TOP_N            = 3                         # how many best strategies to review
WEIGHTS = {                                  # composite‑score weightings
    "return":   0.35,
    "sharpe":   0.35,
    "drawdown": 0.15,   # lower is better → we invert later
    "trades":   0.15,
}

LLM = ChatOpenAI(
    model       = "nvidia/llama-3.3-nemotron-super-49b-v1",
    api_key     = os.getenv("OPENAI_API_KEY"),
    base_url    = "https://integrate.api.nvidia.com/v1",
    temperature = 0.4,
)

PROMPT = PromptTemplate.from_template("""
You are a quantitative strategy manager.

For each of the {top_n} strategy records below (JSON list), return:
  • `strategy_id`          – use its timestamp
  • `summary`              – max 30 words on why it outperformed
  • `tweak`                – one specific improvement to entry/exit logic
  • `sl_pct`, `tp_pct`     – stop‑loss / take‑profit in %
  • `exp_return_3mo`       – expected 3‑month return in %
  • `confidence`           – 0–1

DATA:
{data}
""")

# ──────────────────────────────────────────────
# Helper functions
# ──────────────────────────────────────────────
def load_report(path: Path) -> pd.DataFrame:
    if not path.exists():
        raise FileNotFoundError(f"Report not found: {path}")
    return pd.read_excel(path)

def compute_score(df: pd.DataFrame) -> pd.Series:
    """Composite score: higher return/sharpe + more trades, lower drawdown."""
    pct_rank = lambda s: s.rank(pct=True)                # 0–1, ascending
    score = (
          WEIGHTS["return"]   * pct_rank(df["improved_return_pct"])
        + WEIGHTS["sharpe"]   * pct_rank(df["improved_sharpe"])
        + WEIGHTS["drawdown"] * (1 - pct_rank(df["improved_max_drawdown_pct"]))
        + WEIGHTS["trades"]   * pct_rank(df["improved_n_trades"])
    )
    return score

def build_prompt(df_top: pd.DataFrame, top_n: int) -> str:
    payload = df_top.to_dict(orient="records")
    return PROMPT.format(top_n=top_n, data=json.dumps(payload, indent=2))

def analyse(report_file: str = REPORT_FILE, top_n: int = TOP_N) -> str:
    base_dir   = Path(__file__).resolve().parent
    report_dir = (base_dir / ".." / "reports").resolve()
    report_path = report_dir / report_file

    df = load_report(report_path)

    # Ensure required columns exist
    needed = [
        "improved_return_pct", "improved_sharpe",
        "improved_max_drawdown_pct", "improved_n_trades",
    ]
    missing = [c for c in needed if c not in df]
    if missing:
        raise ValueError(f"Missing columns in report: {missing}")

    df = df.copy()
    df["score"] = compute_score(df)
    df_top = df.nlargest(top_n, "score")

    prompt_text = build_prompt(df_top, top_n)
    response    = LLM.invoke(prompt_text)
    content     = response.get("text", response) if isinstance(response, dict) else str(response)

    # Persist suggestions
    insights_dir = report_dir / "insights"
    insights_dir.mkdir(exist_ok=True)
    stamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    (insights_dir / f"insights_{stamp}.json").write_text(content)

    return content

# ──────────────────────────────────────────────
# Entry point
# ──────────────────────────────────────────────
if __name__ == "__main__":
    suggestions = analyse()
    print("\nLLM Strategy Suggestions:\n")
    print(suggestions)